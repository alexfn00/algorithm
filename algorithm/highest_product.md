## 问题讨论
给出一个包含 N 个整数的数组。
通过将 3 个元素相乘找到最高乘积

限制：
3 <= B <= 5e5

例如：
```
输入：[1, 2, 3, 4]
输出： 2 * 3 * 4 = 24
```

```
输入：[0, -1, 10, 7, 5]
输出： 5 * 7 * 10 = 350
```

## 问题分析
- 1、如果列表只有 3 个元素，则最大乘积是这 3 个元素的乘积，无论元素是正数、负数还是 0。
- 2、如果列表中全部是正数，直接取 3 个最大的正数相乘，可以得到最高乘积。
- 3、如果列表中有 1 个负数，乘积会为负数，因此不可能得到最大值。
- 4、如果列表中有 2 个负数，由于负负得正，两个负数与一个正数相乘可能比 3 个正数相乘得到的值更大，因此需要考虑这两个负数。
- 5、如果列表中超过 2 个负数，3 个负数相乘仍然是负数，因此无法得到最大值。这种情况下，问题与第 4 种情况类似，需要选取其中两个负数与最大的正数相乘。

```
[-5，-2, -1, 0, 0，3，4, 5] -> 3 * 4 * 5 = 60
[-5，-2, -1, 0, 0，1，1, 5] -> -5 * -2 * 5 = 50
```

## 算法思路：
根据上述分析，可以将情况简化为两种：

列表中 3 个最大元素相乘的结果。
列表中 2 个最小元素与 1 个最大元素相乘的结果。
最终，取这两者之间的较大值，即可得到列表中元素的最高乘积。

## 代码实现
```python
def maxp3(lst):
    if len(lst) < 3:
        raise ValueError("The list must contain at least three numbers.")
    
    # 获取排序后的列表的前三个最大值和前两个最小值
    lst.sort()
    max1, max2, max3 = lst[-1], lst[-2], lst[-3]  # 三个最大值
    min1, min2 = lst[0], lst[1]  # 两个最小值
    
    # 计算两种可能的最高乘积
    hi3 = max1 * max2 * max3  # 三个最大元素的乘积
    low2hi1 = min1 * min2 * max1  # 两个最小元素与一个最大元素的乘积
    
    # 返回更大的那个乘积
    return max(hi3, low2hi1)

# 示例测试
result = maxp3(lst=[-5, -2, -1, 0, 0, 3, 4, 5])
print(result)

result = maxp3(lst=[-5, -2, -1, 0, 0, 1, 1, 5])
print(result)
```

运行结果
```
60
50
```